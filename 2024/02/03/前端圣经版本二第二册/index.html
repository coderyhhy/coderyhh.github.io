<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        狼来了
    </title>
    <meta name="description" content= 这里是coderyhh的学习博客。欢迎访问！ >
    <meta name="keywords" content= coderyhh >
    
<link rel="stylesheet" href="/coderyhh.github.io/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/coderyhh.github.io/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/coderyhh.github.io/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            前端圣经版本二第二册
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>xhr.status</p>
<ul>
<li>2xx 表示成功处理请求<ul>
<li>200 表示本次请求完美成功</li>
<li>201 表示本次请求成功, 但是参数不对</li>
</ul>
</li>
<li>3xx 表示重定向,  浏览器直接跳转, 比如跳转到路径引到 404<ul>
<li>302 表示重定向, 比如用户请求 A 链接, 服务器返回响应的时候, 引到浏览器跳转到 B 链接</li>
<li>304 表示协商缓存, 比如说, 用户请求某个资源, 服务器发现浏览器上还存有该文件, 那么服务器就不会返回这个文件, 而且把响应码变为 304 告知浏览器继续使用内存中的那个资源, 可以减少请求消耗的时间, 加快页面展示速度</li>
</ul>
</li>
<li>4xx 客户端请求错误<ul>
<li>403 代表权限不够拒绝返回,  大概率是账号权限不够</li>
<li>404 代表找不到该资源, 请求后端的接口或文件, 后端没有对应的资源, 那么就会返回 404</li>
</ul>
</li>
<li>5xx 服务端错误<ul>
<li>500 代表服务器崩溃无法处理该请求</li>
<li>501 达标服务器无法处理该请求 请求方式不对</li>
</ul>
</li>
</ul>
<h3 id="区别-Ajax-请求与一般HTTP请求"><a href="#区别-Ajax-请求与一般HTTP请求" class="headerlink" title="区别 Ajax 请求与一般HTTP请求"></a>区别 Ajax 请求与一般HTTP请求</h3><p>注意:</p>
<ul>
<li>对服务端来说, 没有任何区别, 区别在浏览器端</li>
<li>浏览器发出的请求, 只有 xhr 或fetch发出</li>
<li>浏览器接受到响应<ul>
<li>一般请求:  浏览器会直接显示响应体数据, 也就是我们常说的刷新跳转页面</li>
<li>ajax 请求;  浏览器不会对界面进行更新操作, 只是调用监视的回调函数并传入响应相关数据</li>
</ul>
</li>
</ul>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><p>防抖和节流是什么</p>
<ul>
<li>它是 JS 代码的一种书写,  使用了它之后, 可以优化代码性能</li>
</ul>
<p>为什么要用防抖和节流</p>
<ul>
<li>某些函数, 在一段时间之内, 连续触发多次, 但是得到的效果是一样的, 浪费代码性能</li>
<li>主要就是该按钮设计到发送请求之类的操作, 后端就会收到很多次请求, 会加大后端服务器压力</li>
</ul>
<p>解决方案</p>
<ul>
<li>尽可能降低这些函数的执行频率</li>
</ul>
<p>想要的效果</p>
<ul>
<li>在一段事件之内, 连续触发多次函数, 只会有一次生效</li>
<li>防抖写法:<ul>
<li>在一段时间之内, 连续触发多次函数, 最后一次触发会生效, 之前的触发都会取消</li>
<li>在防抖开启的时候, 在一段时间之内, 如果由第二次开启防抖, 那么上一次取消</li>
</ul>
</li>
<li>节流写法<ul>
<li>在一段时间之内, 连续触发多次的函数, 第一次触发生效, 剩余的都会被取消</li>
<li>在第一次触发之后, 在一定的时间内不能触发第二次</li>
</ul>
</li>
<li>无论是防抖还是节流, 度可以设置一个时间段</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclikc</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用场景</p>
<ul>
<li>防抖和节流的区别<ul>
<li><p>回调函数执行时机</p>
<ul>
<li>节流的回调函数会被立即执行 (没有延迟时间)</li>
<li>防抖的回调函数会被延迟执行 (有一个定时器)</li>
</ul>
</li>
<li><p>数据的时效性</p>
<ul>
<li><p>节流的数据时效性很差</p>
<ul>
<li>因为节流是多次触发中, 第一次生效,  所以它是用数据第一次数据</li>
</ul>
</li>
<li><p>防抖时效性好</p>
<ul>
<li>因为防抖是很多次触发最后一次生效, 它能拿到最新的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>项目搜索框单词联想, 可以使用防抖,  可以对登录按钮使用节流写法, 因为用于在短时间内点击多次登录, 得到的效果是一样的</p>
</li>
</ul>
</li>
</ul>
<h3 id="跨域相关"><a href="#跨域相关" class="headerlink" title="跨域相关"></a>跨域相关</h3><p>什么是跨域</p>
<ul>
<li><p>跨域就是违反浏览器的同源策略</p>
</li>
<li><p>同源策略是什么</p>
<ul>
<li><p>两个 url 的协议名, 域名, 端口 三者都相同, 那么说明这两个 url就是同源的</p>
</li>
<li><p>url 组成部分: 协议名 + 域名 + 端口号 + 查询字符串</p>
<ul>
<li>查询字符串是由接口路径 + 请求参数组合而成</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个链接协议名不同, 所以不同源</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:8000/home</span></span><br><span class="line"><span class="attr">ftp</span>:<span class="comment">//localhost:8000/home</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个链接域名不同, 所以不同源</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:8000/home</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//127.0.0.1:8000/home</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个链接只有查询字符串不同, 但是查询字符串不在判断之内, 所以同源</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:8000/home</span></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//localhost:8000/about</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>为什么要有跨域报错</p>
<ul>
<li>前言:  真网站 称为 A 网站,  假网站 称为 B网站</li>
<li>如果跨域不报错, 会导致的结果, 用户在不知情的情况下, 请求了 B网站,  B网站返回HTML 文件给浏览器,  浏览器会自动解析执行该网页 JS 代码, JS 代码会使用 Ajax往 A 网站发送请求, 并将 A网站的 cookie携带 A发送网站得到cookie之后, 返回个人真实数据, 最终数据被 B网站接收</li>
<li>这个过程中, 用户直接损失了个人的真实数据, 而 A 网站损失了用户</li>
</ul>
</li>
<li><p>跨域一定报错吗</p>
<ul>
<li>不一定会报错</li>
<li>服务器之间跨域不报错</li>
<li>video  audio  link  script  img 等标签跨域也不会报错</li>
<li>小总结:  跨域是一个动作, 它不一定会带来一个严重的后果</li>
</ul>
</li>
<li><p>什么情况下会出现跨域问题</p>
<ul>
<li>在浏览器上会出现</li>
<li>在发送 Ajax请求的时候, 才会出现</li>
<li>小总结: 跨域问题是 浏览器搞的鬼</li>
</ul>
</li>
<li><p>哪些请求算是 Ajax 请求 (ajax  async  JavaScript  and  xml)</p>
<ul>
<li>只有使用 JS 发送的请求才可能是 Ajax请求</li>
<li>无论http 还是 Ajax, 服务器接受到的都是 HTTP 请求</li>
<li>小总结:  Ajax 请求并不是一种特殊的请求, Ajax只是发送请求的技术</li>
</ul>
</li>
<li><p>跨域问题解决方案</p>
<ul>
<li><p>JSONP</p>
<ul>
<li><p>原理: 利用 script 标签, 请求跨域资源不会报错的漏洞来实现的</p>
</li>
<li><p>流程</p>
<ul>
<li><p>前端在网页中, 存储数据变量 data 和接收数据的函数 getData</p>
</li>
<li><p>当用户点击按钮时, 创建一个 script 标签, 并给对齐记性src属性赋值</p>
<ul>
<li>src属性值 应该是后端指定的接口</li>
</ul>
</li>
<li><p>添加 src 中, 需要把前端的函数名称 getData传递给候选</p>
</li>
<li><p>后端服务器接收到的请求, 需要根据得到的函数名称 以及想要返回的数据, 组合成一个全新的字符串并返回</p>
</li>
<li><p>浏览器的 script 接收到服务器返回的字符串, 会自动执行内部代码</p>
</li>
<li><p>最终前端的 getData 函数会被调用, 得到后端传递的书</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>该方案上下之后也能使用</li>
<li>可以实现不同域名之间的配合, 只要对方公司配合</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>只能发送 get ‘请求</li>
<li>前端需要准备函数, 后端需要准备接口, 所以很麻烦</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>发起请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> data </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">data</span> = data</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">src</span> = <span class="string">&quot;http://lcahost:5000/jsonp?callbackgetData&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CORS (跨域资源共享)</p>
<ul>
<li><p>原理:  跨域报错是为了保护用户以及请求网站的数据安全</p>
<ul>
<li>只要服务器返回数据的时候, 跟浏览器说一声, 愿意被当前网站请求即可</li>
</ul>
</li>
<li><p>流程: </p>
<ul>
<li>只要服务器在返回响应的时候, 在响应头中添加属性 <em>Access-Control-Allow-Origin</em> 即可 *是所有都能访问, 一般比如会写 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>非常简单, 前端什么都不需要做, 只需要正常请求即可</li>
<li>该方案上线之后也能用</li>
<li>可以实现不同域名之间的请求, 只要对方公司配合</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>必须后端配合, 后端需要进行特殊配置</li>
</ul>
</li>
</ul>
</li>
<li><p>proxy</p>
<ul>
<li>原理<ul>
<li>通过与浏览器与数据服务器之间, 搭建一个开发服务器作为中间层, 对请求进行转发, 从而达到浏览器没有跨域请求, 还能得到数据的效果</li>
</ul>
</li>
<li>流程<ul>
<li>开发中在脚手架中, 配置proxy规则, 用于提前告知 devServe 哪些请求时需要转发的</li>
<li>浏览器通过给需要转发的请求, 添加基础路径 baseURL, 并请求服务器</li>
<li>服务器接收到请求之后, 发现 baseURL 与 proxy中的某条规则配置相同,  就会将请求转发给指定的target服务器<ul>
<li>转发过程中, 会将路径进行 path Rwerite (路径重写),  将路径中的 baseURL 删除, 只留下真正的请求接口地址</li>
</ul>
</li>
<li>目标服务器接收请求之后, 返回数据给 devServer</li>
<li>devServer 将接收到的数据返回给前端浏览器使用</li>
</ul>
</li>
<li>优点:<ul>
<li>前端只需要少量的配置, 就可以解决跨域问题</li>
</ul>
</li>
<li>缺点<ul>
<li>该方案只能在开发过程中使用, 上线之后 devServer将会消失</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exprots</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">                <span class="attr">changePrigin</span>: <span class="literal">true</span> <span class="comment">// 真正请求当前数据的</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: coderyhh | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/coderyhh.github.io/libs/jquery.min.js"></script>


<script src="/coderyhh.github.io/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/coderyhh.github.io/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
